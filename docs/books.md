# Zenn Book 構成案：TypeScriptエンジニアのためのGenAIOps入門

## 書籍情報
- **タイトル**: TypeScriptエンジニアが挑む！GenAIOps独習ロードマップ 〜GeminiとLangChainで始めるAIアプリ開発〜
- **ターゲット**: 
    - 普段はTypeScript/Node.jsを書いているWebエンジニア
    - AIに興味はあるが、Pythonやインフラ（Ops）周りに不安がある人
    - 「触ってみた」レベルを卒業し、実務で使えるレベル（GenAIOps）を目指す人

## コンセプト
- **"From TypeScript to Python"**: 
    - 常にTypeScript/Node.jsの概念（npm, node_modules, async/await, Type）と比較しながら解説する。
- **"Gemini First"**: 
    - 多くの教材がOpenAI前提の中で、コストパフォーマンスと性能に優れた**Gemini 2.5 (Flash)** を採用する独自性を出す。
- **"Ops Mindset"**:
    - 単に動くコードを書くだけでなく、「コスト」「レイテンシ」「観測性」を意識した構成にする。

---

## チャプター構成 (Week 1: Python & GenAI基礎)

### 第1章: TSエンジニアのためのPython環境構築とGemini API
- **スラッグ**: `week1-01-setup-gemini`

### 第2章: ステートレスなAIに「記憶」を実装する
- **スラッグ**: `week1-02-memory-context`

### 第3章: Pythonでも型安全に書きたい！ (Type Hints入門)
- **スラッグ**: `week1-03-python-typing`

---

## チャプター構成 (Week 2: RAG & Backend)

### 第4章: AIに「ドキュメント」を読ませる技術 (RAG入門)
- **スラッグ**: `week2-01-rag-basics`

### 第5章: FastAPIでPython製のAI APIサーバーを構築する
- **スラッグ**: `week2-02-fastapi-server`

---

## チャプター構成 (Week 3: GenAIOps実践 - 観測・評価・改善)

AIアプリを「作りっぱなし」にしないための、運用と改善のサイクルを学ぶ。

### 第6章: AIの「健康診断」：Langfuseで観測性を手に入れる
- **スラッグ**: `week3-01-observability-langfuse`
- **概要**:
    - なぜLLMアプリに「観測性」が不可欠なのか？（コスト、レイテンシ、品質の追跡）
    - Langfuseとは何か？：AIアプリケーションのためのオープンソース観測プラットフォーム
    - **実践**: FastAPIサーバー (`server.py`) にLangfuseのコールバックハンドラを数行追加し、APIへのリクエスト／レスポンスを追跡する。
- **実装のポイント**:
    - LangfuseのUIで、各APIコールのトレース（入力、出力、使用トークン数、レイテンシ）がどのように可視化されるかを確認する。
    - ユーザーからのフィードバック（Good/Bad評価など）をLangfuseに記録する方法の基礎に触れる。

### 第7章: 「AIの通信簿」：Langfuseを使った評価とプロンプト管理
- **スラッグ**: `week3-02-evaluation-prompt-management`
- **概要**:
    - 「良いプロンプト」をどう判断するか？ LLM評価の考え方（`pytest`では不十分な理由）
    - **評価データセット**: テストしたい質問と理想的な回答の雛形をCSVやJSONで用意する。
    - **実践（評価）**: 用意したデータセットを使ってバッチ処理を実行し、結果をLangfuseに記録。新旧プロンプトの回答を並べて比較・採点する。
    - **実践（プロンプト管理）**: プロンプトをコードにハードコーディングするのではなく、LangfuseのPrompt Management機能から動的に取得し、バージョン管理する。
- **実装のポイント**:
    - Langfuse SDKを使った評価ジョブの実行方法。
    - A/Bテストも可能にする、本番環境でのプロンプト管理の重要性を理解する。

### 第8章: AIの安全装置：Guardrailsで品質と安全性を守る
- **スラッグ**: `week3-03-guardrails`
- **概要**:
    - なぜLLMアプリに「ガードレール」が必要なのか？（プロンプトインジェクション、有害出力、フォーマット崩れ）
    - 入力バリデーション：悪意あるプロンプトを検知・拒否する
    - 出力バリデーション：PydanticとLangChain OutputParserで構造化出力を強制する
    - **実践**: FastAPIサーバーにGuardrailsを組み込み、安全性を高める
- **実装のポイント**:
    - プロンプトインジェクション対策の基本パターン
    - 構造化出力（JSON）の強制とエラーハンドリング

### 第9章: RAGの精度を高める：検索品質の改善テクニック
- **スラッグ**: `week3-04-rag-improvement`
- **概要**:
    - RAGの品質を決める要因（チャンク戦略、検索精度、コンテキスト選択）
    - チャンク戦略の見直し：サイズ、オーバーラップ、セマンティックチャンキング
    - Metadata filtering：ドキュメントにメタデータを付与して検索精度を向上
    - Reranking：検索結果を並べ替えて関連性を高める
    - **実践**: ChromaDBのメタデータフィルタリングを実装する
- **実装のポイント**:
    - 「検索の質」が「回答の質」を決めるという考え方
    - 評価データセットを使ったRAG改善の効果測定

---

## チャプター構成 (Week 4: デプロイとUI接続)

本番環境へのデプロイと、動作確認のためのシンプルなUI接続を素早く行う。

### 第10章: クラウドへのデプロイとUIの接続
- **スラッグ**: `week4-01-deploy-and-ui`
- **概要**:
    - **コンテナ化**: FastAPIアプリをDockerコンテナにパッケージングする（デプロイに必要な最小限の解説）
    - **デプロイ**: Google Cloud RunやAWS App Runnerのようなサーバーレス環境にデプロイする。
    - **UI接続**: 使い慣れたNext.jsのシンプルなテンプレート（完成品を提供）を使い、デプロイしたAPIエンドポイントに接続するまでを体験する。
- **実装のポイント**:
    - 本番環境への環境変数（APIキー、Langfuseキー）の渡し方。
    - CORSの設定。
    - フロントエンドの構築ではなく、「疎結合なバックエンドとフロントエンドを接続する」というアーキテクチャに焦点を当てる。

### 第11章: 総仕上げとGenAIOpsのその先へ
- **スラッグ**: `week4-02-summary-and-next-steps`
- **概要**:
    - GenAIOpsのループ（開発→観測→評価→改善→デプロイ）を振り返る。
    - **ストリーミング対応**: `StreamingResponse`の実装を「次のステップ」として紹介し、UX向上のための道筋を示す。
    - さらなる発展（ファインチューニング、より高度なエージェント、アラート機構の構築など）について言及する。